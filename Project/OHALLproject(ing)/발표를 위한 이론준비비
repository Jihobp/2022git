create table user(
user_id varchar(30) primary key,
user_pw varchar(255) not null,
user_name varchar(50) not null,
user_gender varchar(10) default '',
user_birth varchar(10) default '',
user_email varchar(50) not null,
user_phone varchar(20) not null,
user_interest varchar(30) default '',
user_reg_date datetime not null default now()
);

회원가입 우리 db에 맞게 수정. id, pw, 이름, 성별, 생일, 이메일, 휴대폰번호, 관심사
이거만 들어가게. 성별은 남자, 여자, 비공개로 체크 가능하게

🥓발표는 1번 프로젝트 의견부터 8번 자체평가의견순으로 진행하겠습니다.
🥓서구와 수성구의 카페목록을 공공데이터 포털을 이용해서 불러왔고, 그걸 이용해서 d3를 구현하였습니다. 

❤수정할것
🖤로그인창 /////형태 완성 > 이미지 수정하기 ✔
✔회원가입창/////형태 완성  >>>> 수정 하기..>✔ 수정완료
🖤계정정보(=계정수정) >>>>  회원가입창을 수정하든지? 
✔메인페이지   >> 완료. + 🖤테마 추가할지도??? 


💕💕💕💕할것💕💕💕💕
✖인스타 자기 피드 만들기??!!!?!?!?!?!?!?!
🖤d3 그래프. >>>>
🖤글작성(=글수정) 
🖤ohall 로고

-----------------------------------------------------------------------
src/main/java에 패키지를 만들어줍니다.

kr.co.controller

kr.co.dao 

kr.co.service 

kr.co.vo

여기서 controller의 역할은 웹에서 처리해야할 데이터를 받고, 
이 데이터를 담당할 service를 선택하여 호출합니다.
그리고 처리한 데이터를 다음 페이지에서 볼 수 있게 셋팅하며 이동할 페이지를 리턴합니다.
service는 데이터를 dao를 통해 넘겨주거나 받으면서 비즈니스 로직을 수행하는 역할을 합니다.
dao는 DB를 통해 데이터를 조회하거나 수정 삭제 하는 역할을 합니다.
vo는 DB에 있는 테이블 컬럼 값을 java에서 객체로 다루기 위해 사용합니다.




스프링을 이해하기 위해
스프링을 제대로 이해하기 위해선 객체지향 개념부터 확실히 알 필요가 있다.
Spring MVC가 돌아가는 방식은 ‘어노테이션’을 이용한 의존성 주입(Dependency Injection)을 이용하기 때문에
겉으로 보아선 이해하기 힘들다.
위 사진은 스타크래프트란 게임의 ‘마린’과 ‘SCV’ 유닛의 상태창이다.
각각의 버튼들마다 각기 다른 기능을 담고있다.

두 유닛을 보면 상위 3가지 버튼은 동일하고 나머진 다른 버튼임을 알 수 있다.
스타크래프트에서 대부분의 유닛들은 모두 저 3가지 버튼을 가지고 있는데,
순서대로 ‘이동, 정지, 공격’이다.

이를 객체지향형 프로그램에 대입해 보자.
간단한 정리를 해보면



모든 유닛들은 ‘이동, 정지, 공격’의 공통 기능을 가지고 있다.
각 유닛 종류마다 공통 기능을 제외한 고유한 기능을 가지고 있다.
빨간 테두리 부분이 공통 기능, 초록 테두리가 고유 기능이 된다.
객체지향언어(Java 등)에서 공통 기능을 가진 부분은 인터페이스로 정의하면 된다.
고유 기능을 가진 부분은 해당하는 클래스를 생성하면 된다.

자바에선 인터페이스는 다중상속이 가능하지만, 클래스는 다중상속이 불가능하다.

예를 들어 마린 10마리를 생성한다고 생각하자.
각 마린 객체들은 유닛 인터페이스와 마린 클래스를 상속받게 된다.
그렇게 생성된 각각의 마린들은 초기엔 모두가 같은 상태, 같은 값을 가지게 되지만,
전투 등에 의해 체력이 닳으면 각각의 생성된 객체의 hp값만 수정해주면 된다.

이렇게 하나의 마린 유닛에 대한 정보를 하나의 클래스 안에 전부 작성하지 않고,
인터페이스, 클래스를 만들어 모두 객체화 시킨 뒤 이를 이용하는것이 객체지향의 기본 개념이다.

객체지향 사용 이유?Permalink
위에서 아주 간단하게 객체지향 개념에 대해 알아보았다.
이러한 객체지향을 사용하는 이유는 무엇일까?
가장 큰 이유는 유연성이다. 객체지향 언어는 상당히 유연하다.

위에서 생성한 10마리의 마린들이 객체지향이 아닌 언어로 작성했다고 가정하자.
10마리의 마린 모두 상속 없이 각각의 클래스 안에서 작성되어 있다면,
게임의 밸런스 패치, 게임속 업그레이드 등의 상황에서 10개의 클래스를 모두 찾아가
수정된 내용을 적용해주어야 한다.

반면에 객체지향적으로 구성되어 있다면 단순히 마린 클래스(슈퍼 클래스)를 찾아가 수정된 내용만 적용하면
해당 클래스를 상속받아 만들어진 10마리의 마린들이 모두 한 번에 적용받게 된다.

인터페이스도 마찬가지다.
새로운 유닛이 추가되거나, 모든 유닛이 사용할 수 있는 새 기능이 추가되는 등 상황에서
유닛 인터페이스를 이용하면 상속받는 모든 유닛에 동일하게 적용할 수 있다.
---------------------------------------------------------
라이브러리 추가
이 전 포스팅에서 Maven을 통해 라이브러리를 추가하는법을 알아보았다.
 pom.xml이란 파일이 생성되어 있다.
메이븐(Maven)이란 자바 프로젝트의 환경 설정 등을 도와주는 Tool이다.

MyBatis를 이용해 Oracle연동을 하기 위해 필요한 라이브러리 몇 가지를 pom.xml에 추가한다.

MyBatis에 관한 설정을 하기 위해 src/main/resources안에 mybatis-config.xml파일을 생성한다.
mybatis-config.xml안에 아래와 같이 작성해준다.

Oracle DB와 연동하기 위해 root-context.xml파일에 다음 내용을 추가한다.
위의 <bean> 안의 내용은 오라클 DB와 연결하는 내용이고
아래 <bean> 안의 내용은 연결한 오라클 DB에 관한 설정 파일들에 관한 내용이다.
오라클 사용자 이름과 비밀번호는 본인이 생성한 DB 사용자로 설정하면 된다.
위의 <bean> 안의 내용은 오라클 DB와 연결하는 내용이고
아래 <bean> 안의 내용은 연결한 오라클 DB에 관한 설정 파일들에 관한 내용이다.
내용을 제대로 추가했다면 아마 오류표시가 뜰 것이다.
이유는 네임스페이스가 제대로 추가되지 않았기 때문인데 
Mybatis-spring, Spring-jdbc 라이브러리가 제대로 설치되었다면 아래와 같이 네임스페이스를 추가할 수 있다.
root-context.xml을 키고 하단에 Namespaces탭을 클릭하면 위와같은 화면이 나온다.
여기서 mybatis-spring을 체크하고 저장하면 된다.

----------------------------
MVC 모델 설계Permalink
이제 기본적인 설정에 관한 내용은 끝났다.
MVC 모델에 맞게 프로젝트 내부를 구성하는 과정이다. 천천히 따라온다면 어렵지 않을것이다.

우선 com.my.spring.mapper 패키지(root-context.xml에 정의된 경로)를 생성한 후 BoardMapper.java 인터페이스를 만든다.
src/main/resources 안에 mapper 폴더를 만들고 
그 안에 BoardMapper.xml파일을 생성한다.??????
이 경로 또한 root-context.xml안에 정의했다.
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd">
<mapper namespace="com.my.spring.mapper.BoardMapper">	
</mapper>
BoardMapper.xml안에 위 내용을 작성해준다.
중요한 점은 namespace 내용에 위에 생성한 클래스 경로를 정확하게 작성해 주어야 한다.

다음으로 com.my.spring.service 패키지와 com.my.spring.service.impl 패키지를 생성한다.
service 패키지엔 BoardService 인터페이스를 생성하고 service.impl 패키지엔
생성한 BoardService 인터페이스를 상속받는 BoardServiceImpl 클래스를 생성한다.

com.my.spring.domain 패키지를 생성하고 BoardVO 클래스를 만들어준다. =DAO
BoardVO엔 Oracle에서 생성한 테이블에 대한 VO가 작성된다.
오라클에서 BOARD란 테이블을 다음과 같이 생성하였다.
-dao, dto 해서 받을 매개변수 받음 ㅇㅅㅇ. getter setter!

--------------------

위 내용을 보면 맨 아래 부분에 name=”mapperLocations”라 작성된 부분에 클래스 패스로 /mapper/*Mapper.xml을 작성해 놓았다.
이 뜻은 /mapper 안에 있는 *Mapper.xml(뒷 부분이 Mapper.xml로 끝나는 파일)에 대해 매퍼로 지정한다는 의미다.
따라서 우리가 생성한 BoardMapepr.xml역시 매퍼로 지정된다.

<!-- 전체 내용 조회 -->
<select id="viewAll" resultType="com.my.spring.domain.BoardVO">
  SELECT * FROM board ORDER BY SEQ DESC
</select>
BoardMapper.xml 파일에 위의 내용을 작성하자.끝에 세미콜론(;)은 넣으면 안된다!
id는 해당 SQL문을 호출하기 위한 이름이고 resultType은 결과값을 받을 타입을 지정한 것이다.
결과값으론 이전에 만든 BoardVO타입으로 하되 패키지명까지 정확히 써줘야 한다.
src/main/resources 안에 만든 mybatis-config.xml파일을 이용하면 alias(별칭)를 등록할 수 있어
패키지명까지 쓸 필요없이 간단히 쓸 수 있지만 이번 포스팅에선 그 과정을 생략한다.


Mapper 인터페이스Permalink
<mapper namespace="com.my.spring.mapper.BoardMapper">
BoardMapper.xml을 보면 상단에 위와 같이 작성되어 있을것이다.
SQL문을 작성한 매퍼와 namespace로 등록한 인터페이스를 연동한다는 뜻이다.
해당 인터페이스로 이동해 아래와 같은 코드를 작성해준다.

public List<BoardVO> viewAll();
위에서 작성한 SQL문의 결과값이 여러개일 수 있으므로
BoardVO타입만 담을 수 있는 List타입으로 메소드를 정의하고
매퍼파일에서 불러올 SQL문의 id를 메소드 이름으로 입력해준다.


-----------------------


table db 만들고 >boardmapper 에서 받고,
kr.co.controller 4.kr.co.controller에 BoardController.java 파일을 만들고 코드를 작성해 줍니다.
kr.co.dao 2. kr.co.dao에 BoardDAO와 BoardDAOImpl을 만들어서 코드를 작성해 줍니다.
kr.co.service  3.BoardService와 BoardServiceImple을 만들어서 코드를 작성해 줍니다.
kr.co.vo  1. 게터세터

5.이제 스프링이 스캔 할수 있도록 root-context.xml파일에 코드를 추가해줍니다.


여기서 controller의 역할은 웹에서 처리해야할 데이터를 받고, 
이 데이터를 담당할 service를 선택하여 호출합니다.
그리고 처리한 데이터를 다음 페이지에서 볼 수 있게 셋팅하며 이동할 페이지를 리턴합니다.
service는 데이터를 dao를 통해 넘겨주거나 받으면서 비즈니스 로직을 수행하는 역할을 합니다.
dao는 DB를 통해 데이터를 조회하거나 수정 삭제 하는 역할을 합니다.
dto=vo는 DB에 있는 테이블 컬럼 값을 java에서 객체로 다루기 위해 사용합니다.




-----------------------
@RequestMapping이란 어노테이션이 사용됐다.
이 어노테이션의 역할은 ()안에 있는 경로와 컨트롤러를 이어주는것(매핑)이다.
“루트/”경로로 접속을 시도하면 MainController가 담당을 하고 아래 메소드에 있는 경로들은 “루트/” 뒤에 붙는 값이 된다.















-----------------------------------------
주제선정
다양한 데이터를 실시간으로 입력 받고 처리해야 하는 DB시스템의 특성상, 현대시대의 사람들이 가장 많이 이용하는 애플리케이션인 SNS를 직접 구축 해 보는 것이 적합하다고 판단하여 팀 프로젝트 주제로 선정하였습니다. 
그리고 DB프로젝트와 연계하여 이번에 진행했던 웹 프로젝트까지 고려하였을 때 실습한 내용을 기반으로 SNS 페이지=대시보드나 게시판까지 구현할 경우에 SNS가 가장 알맞은 주제라고 판단하였습니다.

또한 우리가 늘 사용하며 친근하게 접하는 SNS이기에 팀 프로젝트를 진행하고 공부하는 내내 팀원들의 흥미와 재미를 불러 일으키는 주제로 충분할 것이라고 예측하였습니다. 
모두가 실제 생활에서 사용하기 때문에 그에 대한 장단점이나 개선점, 새로운 아이디어를 제시하는 데에도 부담이 적어서 적극적으로 팀 프로젝트를 진행하기에 좋을 것이라고 생각하였습니다.



앞서 진행했던 DB프로젝트와 연계하여 사람들이 가장 많이 이용하는 애플리케이션인 SNS를 주제로 선정하였습니다.
그동안 실습한 내용을 바탕으로 SNS 페이지 및 게시판, 대시보드까지 구현한다면 저희에게 많은 공부가 될 것이라고 판단하였습니다.

또한 우리가 늘 사용하며 친근하게 접하는 SNS이기에 팀 프로젝트를 진행하고 공부하는 내내 팀원들의 흥미와 재미를 불러 일으킬 것이라고 예상하였고,
모두가 실생활에서 사용하기 때문에 장단점이나 개선점, 새로운 아이디어를 제시하는 데에도 부담이 적어, 앞으로 업데이트를 진행하기에 좋을 것이라고 생각하였습니다.